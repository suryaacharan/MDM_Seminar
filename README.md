# README: AsterixDB Query Workflow

This README documents the complete workflow used to analyze a filtered subset of the Yelp dataset, TIGER2018 Road network dataset using Apache AsterixDB. It includes dataset setup, data loading, integrity checks, and advanced geospatial and keyword-based queries.

---

## üîß Setup and Data Loading

```sql
Drop DATAVERSE YelpDataverseSB;
CREATE DATAVERSE YelpDataverseSB IF NOT EXISTS;
USE YelpDataverseSB;

CREATE TYPE YelpUserType If not exists AS {
    user_id: string,
    name: string,
    review_count: int,
    yelping_since: string,
    friends: string,
    useful: int,
    funny: int,
    cool: int,
    fans: int,
    average_stars: double,
    compliment_hot: int,
    compliment_more: int,
    compliment_profile: int,
    compliment_cute: int,
    compliment_list: int,
    compliment_note: int,
    compliment_plain: int,
    compliment_cool: int,
    compliment_funny: int,
    compliment_writer: int,
    compliment_photos: int
};

CREATE DATASET Users(YelpUserType) PRIMARY KEY user_id;

LOAD DATASET YelpDataverseSB.Users
USING localfs
(("path"="localhost:///SantaBarbaraOnly/users.json"), ("format"="json"));

CREATE TYPE YelpBusinessType IF NOT EXISTS AS {
    business_id: string,
    name: string,
    address: string,
    city: string,
    state: string,
    postal_code: string,
    latitude: double,
    longitude: double,
    stars: double,
    review_count: int,
    is_open: int
};

CREATE DATASET Businesses(YelpBusinessType) PRIMARY KEY business_id;

LOAD DATASET YelpDataverseSB.Businesses
    USING localfs
    (("path"="localhost:///SantaBarbaraOnly/businesses.json"), ("format"="json"));

CREATE TYPE YelpReviewType IF NOT EXISTS AS {
    review_id: string,
    user_id: string,
    business_id: string,
    stars: double,
    useful: int,
    funny: int,
    cool: int,
    text: string,
    date: string
};

CREATE DATASET Reviews(YelpReviewType) PRIMARY KEY review_id;

LOAD DATASET YelpDataverseSB.Reviews
    USING localfs
    (("path"="localhost:///SantaBarbaraOnly/reviews.json"), ("format"="json"));

USE YelpDataverseSB;
CREATE TYPE YelpTipType IF NOT EXISTS AS {
    tip_id: uuid,
    user_id: string,
    business_id: string,
    text: string,
    date: string,
    compliment_count: int
};

CREATE DATASET Tips(YelpTipType) PRIMARY KEY tip_id AUTOGENERATED;

LOAD DATASET YelpDataverseSB.Tips
    USING localfs
    (("path"="localhost:///SantaBarbaraOnly/tips.json"), ("format"="json"));

-- Roads
CREATE TYPE RoadsType AS open {
id: uuid,
g: geometry
};
CREATE DATASET Roads(RoadsType)
PRIMARY KEY id AUTOGENERATED;
LOAD DATASET Roads USING localfs
(("path"="localhost:///TIGER2018_ROADS.json"),
("format"="adm"));


```

---

## üìä Review Aggregation

```sql
SELECT b.city AS city, SUM(b.review_count) AS total_review_count
FROM Businesses AS b
GROUP BY b.city
ORDER BY total_review_count DESC;
```

---

## ‚úÖ Integrity Checks

```sql
SELECT VALUE r.review_id
FROM Reviews r
WHERE r.business_id NOT IN (
    SELECT VALUE b.business_id FROM Businesses b
);

SELECT VALUE r.review_id
FROM Reviews r
WHERE r.user_id NOT IN (
    SELECT VALUE u.user_id FROM Users u
);

SELECT VALUE t.tip_id
FROM Tips t
WHERE t.business_id NOT IN (
    SELECT VALUE b.business_id FROM Businesses b
);

SELECT VALUE t.tip_id
FROM Tips t
WHERE t.user_id NOT IN (
    SELECT VALUE u.user_id FROM Users u
);

SELECT VALUE u.user_id
FROM Users u
WHERE u.user_id NOT IN (
    SELECT VALUE r.user_id FROM Reviews r
    UNION
    SELECT VALUE t.user_id FROM Tips t
);

{
  "reviews_with_invalid_business": (
    SELECT COUNT(*) FROM Reviews r
    WHERE r.business_id NOT IN (SELECT VALUE b.business_id FROM Businesses b)
  ),
  "reviews_with_invalid_user": (
    SELECT COUNT(*) FROM Reviews r
    WHERE r.user_id NOT IN (SELECT VALUE u.user_id FROM Users u)
  ),
  "tips_with_invalid_business": (
    SELECT COUNT(*) FROM Tips t
    WHERE t.business_id NOT IN (SELECT VALUE b.business_id FROM Businesses b)
  ),
  "tips_with_invalid_user": (
    SELECT COUNT(*) FROM Tips t
    WHERE t.user_id NOT IN (SELECT VALUE u.user_id FROM Users u)
  )
}
```

---

## üß≠ Add Geometry Field to Businesses

```sql
USE YelpDataverseSB;
UPSERT INTO Businesses (
  SELECT st_make_point(b.longitude, b.latitude) AS g, b.*
  FROM Businesses b
);
```

---

## üìç Geospatial Queries

```sql
USE YelpDataverse;

SELECT *
FROM Businesses b
WHERE st_contains(
  st_geom_from_geojson({
    "type": "Polygon",
    "coordinates": [[
      [-119.698200, 34.414700],
      [-119.698800, 34.411900],
      [-119.695900, 34.409900],
      [-119.692400, 34.409100],
      [-119.688800, 34.409500],
      [-119.686800, 34.411700],
      [-119.687300, 34.413600],
      [-119.689500, 34.415200],
      [-119.692700, 34.415500],
      [-119.695500, 34.415300],
      [-119.698200, 34.414700]
    ]]
  }),
  b.g
);
```

---

## ‚≠ê Avg Stars by Category near a Tourist Line

```sql
USE YelpDataverseSB;

SELECT VALUE {
  "category": trim(c),
  "avg_stars": avg(b.stars)
}
FROM Businesses b
UNNEST split(b.categories, ",") AS c
WHERE st_distance(
  st_geom_from_geojson({
    "type": "LineString",
    "coordinates": [
      [-119.69549266696681, 34.41679198298692],
      [-119.68575084673559, 34.409785253730774],
      [-119.68504617192193, 34.40885709855257]
    ]
  }),
  b.g
) <= 0.001
GROUP BY trim(c);
```

---

## üö¶ Roads with Most 5-Star Businesses Nearby

```sql
USE YelpDataverseSB;

SELECT r.FULLNAME, COUNT(*) AS c
FROM Roads r, Businesses b, Reviews a
WHERE st_distance(r.g, b.g) < 0.0003
  AND a.business_id = b.business_id
  AND a.stars = 5
GROUP BY r.LINEARID, r.FULLNAME
ORDER BY c DESC;
```

---

## üåê GeoJSON Output of Top Roads by Density

```sql
USE YelpDataverseSB;

SELECT
  "FeatureCollection" AS `type`,
  {"name": r.FULLNAME} AS properties,
  (
    SELECT "Feature" AS `type`, {} AS properties, brg.y.g AS geometry
    FROM BRGroup AS brg
  ) AS features
FROM Roads r, Businesses y
WHERE st_distance(r.g, y.g) < 0.0003
  AND y.stars = 5
GROUP BY r.LINEARID, r.FULLNAME, r.g
GROUP AS BRGroup
ORDER BY (COUNT(1) / st_length(r.g)) DESC
LIMIT 10;
```

---

## üîé Full-Text Indexing

```sql
USE YelpDataverseSB;

DROP INDEX Reviews.YelpReviewKWIndex IF EXISTS;
DROP INDEX Businesses.YelpBusinessKWIndex IF EXISTS;

CREATE INDEX YelpReviewKWIndex ON Reviews(text) TYPE keyword;
CREATE INDEX YelpBusinessKWIndex ON Businesses(name) TYPE keyword;
```

---

## ü§ù Jaccard Similarity between Reviews and Business Names

```sql
USE YelpDataverseSB;

SELECT VALUE COUNT(1)
FROM Reviews r, Businesses b
WHERE similarity_jaccard(word_tokens(r.text), word_tokens(b.name)) > 0.5;
```

---

## üìù Review Texts for Matched Businesses (5-star only)

```sql
USE YelpDataverseSB;

SELECT {
  "business_name": b.name,
  "number_of_reviews": COUNT(*),
  "reviews": (
    SELECT r1.r.text
    FROM review_group AS r1
  )
}
FROM Businesses AS b, Reviews AS r
WHERE
  st_contains(
    st_geom_from_geojson({
      "type": "Polygon",
      "coordinates": [[
        [-124.5000, 42.0000],
        [-114.1000, 42.0000],
        [-114.1000, 32.5000],
        [-124.5000, 32.5000],
        [-124.5000, 42.0000]
      ]]
    }),
    b.g
  )
  AND r.business_id = b.business_id
  AND similarity_jaccard(word_tokens(r.text), word_tokens(b.name)) > 0.5
  AND r.stars = 5
GROUP BY b.name
GROUP AS review_group
ORDER BY COUNT(*) DESC;
```

---
